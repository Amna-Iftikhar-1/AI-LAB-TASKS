# -*- coding: utf-8 -*-
"""LabAssignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10eswLoEJvUqAmwF14ROum1jNS_QTIQjR

# Artificial Intelligence Lab Assignment 1

**Name:** AMNA IFTIKHAR

**Roll Number:** SP23-BCS-071

**Course:** Artificial Intelligence (AI)  
**Instructor:** Zeenat Zulfiqar  
**University:** COMSATS University Islamabad, Abbottabad Campus  

---

## ðŸ“Ž Submission Links

- **GitHub Repository:** [AI-Lab-Task](https://github.com/Amna-Iftikhar-1/AI-LAB-TASKS)
- **YouTube Video Links:**
  - Task 1 â€“ BFS & DFS on Trees and Graphs â†’ (https://youtu.be/5_8BNrsVWcU)
  - Task 2 â€“ Dictionary Operations â†’ (https://youtu.be/gzkFm2kGLpM)
  - Task 3 â€“ Matplotlib Line Plot â†’ (https://youtu.be/ZP_51ELdYv4)
  - Task 4 â€“ Water Jug Problem (BFS & DFS) â†’ (https://youtu.be/E4HLw1KD2Yw)
  - Task 5 â€“ A* Search Algorithm (Maze) â†’ (https://youtu.be/Xx8cCzzBHUw)

---

**TASK#1**

Apply BFS and DFS on trees and graphs.
"""

from collections import deque

graph = {
 'A': ['B', 'C'],
 'B': ['D', 'E'],
 'C': ['F'],
 'D': [],
 'E': ['F'],
 'F': []
 }

def bfs(start):
    visited = []
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.append(node)
            queue.extend(graph[node])
    return visited
print("BFS Traversal:", bfs('A'))

def dfs(start, visited=None):
    if visited is None:
        visited = []
    visited.append(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(neighbor, visited)
    return visited
print("DFS Traversal:", dfs('A'))

"""**Task 2**

Dictionary Operations
"""

student = { "name": "Maryam Iqbal",
 "age": 21,
 "roll_number": "BSE-6C-01",
 "grade": "A"}

# 1. Print keys and values
print(student.items())

# 2. Update grade
student["grade"] = "A+"

# 3. Add email
student["email"] = "maryam@example.com"

# 4. Delete roll_number
del student["roll_number"]

print("Updated Student Info:", student)

"""**Task 3**

Line Plot using Matplotlib
"""

import matplotlib.pyplot as plt

X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

plt.plot(X, Y)
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.grid(True)
plt.show()

"""**Task 4**

Water Jug Problem (BFS & DFS)
"""

from collections import deque
import time

def water_jug_bfs(jug1, jug2, target):
    start_time = time.time()
    visited = set()
    queue = deque([(0, 0)])
    while queue:
        a, b = queue.popleft()
        if (a, b) in visited:
            continue
        visited.add((a, b))
        if a == target or b == target:
            print("Solution Found:", (a, b))
            print("Steps Taken:", len(visited))
            print("Time Taken:", time.time() - start_time)
            return
        queue.extend([
            (jug1, b), (a, jug2), (0, b), (a, 0),
            (a - min(a, jug2 - b), b + min(a, jug2 - b)),
            (a + min(b, jug1 - a), b - min(b, jug1 - a))
        ])
    print("No solution found")

water_jug_bfs(4, 3, 2)

visited = set()

def water_jug_dfs(a, b, jug1, jug2, target):
    # Base condition
    if (a, b) in visited:
        return False
    print(f"Visited state: ({a}, {b})")
    visited.add((a, b))

    # If target is reached
    if a == target or b == target:
        print("Solution Found:", (a, b))
        return True

    # Explore all possible moves (like BFS but recursively)
    return (
        water_jug_dfs(jug1, b, jug1, jug2, target) or  # Fill Jug1
        water_jug_dfs(a, jug2, jug1, jug2, target) or  # Fill Jug2
        water_jug_dfs(0, b, jug1, jug2, target) or     # Empty Jug1
        water_jug_dfs(a, 0, jug1, jug2, target) or     # Empty Jug2
        water_jug_dfs(a - min(a, jug2 - b), b + min(a, jug2 - b), jug1, jug2, target) or  # Pour Jug1 â†’ Jug2
        water_jug_dfs(a + min(b, jug1 - a), b - min(b, jug1 - a), jug1, jug2, target)     # Pour Jug2 â†’ Jug1
    )

# Example usage:
water_jug_dfs(0, 0, 4, 3, 2)

"""**Task 5**

Maze Pathfinding using A* Algorithm
"""

from queue import PriorityQueue

# 0 = open path, 1 = wall
# Maze based on your image (6x6 grid)
maze = [
    [0, 1, 0, 0, 0, 0],  # Row 0: A (0,0)
    [0, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0]   # Row 5: Y (5,5)
]

start = (0, 0)  # A
goal = (5, 5)   # Y

# Heuristic function (Manhattan distance)
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = PriorityQueue()
    open_set.put((0, start))
    came_from = {}
    g_score = {start: 0}

    while not open_set.empty():
        _, current = open_set.get()
        if current == goal:
            # Reconstruct path
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            path.reverse()
            return path

        for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:  # Right, Down, Up, Left
            neighbor = (current[0]+dx, current[1]+dy)
            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and maze[neighbor[0]][neighbor[1]] == 0:
                temp_g = g_score[current] + 1
                if neighbor not in g_score or temp_g < g_score[neighbor]:
                    g_score[neighbor] = temp_g
                    f_score = temp_g + heuristic(neighbor, goal)
                    open_set.put((f_score, neighbor))
                    came_from[neighbor] = current
    return None

path = a_star(maze, start, goal)
print("Shortest Path Found by A*:", path)