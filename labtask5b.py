# -*- coding: utf-8 -*-
"""LabTask5b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15inhIrSOAYNZcK-U_HRpECw8HKgwsBan
"""

from collections import deque
import heapq

# Define problem constants
JUG1 = 4  # Capacity of the first jug
JUG2 = 3  # Capacity of the second jug
GOAL = 1  # Target amount of water

## Breadth-First Search (BFS) Implementation
def water_jug_bfs():
    """
    Solves the Water Jug problem using Breadth-First Search (BFS).
    Returns the shortest path (list of states) to reach the goal, or None.
    """
    start = (0, 0)
    visited = set()
    # queue stores paths, where a path is a list of states
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        state = path[-1]

        # Goal Check
        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        # Generate next possible states (possible moves)
        next_states = [
            (JUG1, y), # Fill JUG1
            (x, JUG2), # Fill JUG2
            (0, y),    # Empty JUG1
            (x, 0),    # Empty JUG2
            # Pour JUG1 to JUG2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour JUG2 to JUG1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if 0 <= nxt[0] <= JUG1 and 0 <= nxt[1] <= JUG2 and nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                queue.append(new_path)
    return None

# Execute BFS
bfs_solution = water_jug_bfs()
print("BFS Solution path:")
if bfs_solution:
    for step in bfs_solution:
        print(step)
else:
    print("No solution found.")

print("-" * 20)

## Depth-First Search (DFS) Implementation
def water_jug_dfs():
    """
    Solves the Water Jug problem using Depth-First Search (DFS).
    Returns a path (list of states) to reach the goal, or None.
    """
    start = (0, 0)
    # stack stores paths, where a path is a list of states
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]

        # Goal Check
        if state[0] == GOAL or state[1] == GOAL:
            return path

        # Check visited set (crucial for preventing cycles in DFS)
        if state in visited:
            continue
        visited.add(state)

        x, y = state

        # Generate next possible states (possible moves)
        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            # Pour JUG1 to JUG2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour JUG2 to JUG1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        # Push to stack in reverse order to explore the first generated state first (common convention)
        for nxt in reversed(next_states):
            if 0 <= nxt[0] <= JUG1 and 0 <= nxt[1] <= JUG2 and nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                stack.append(new_path)
    return None

# Execute DFS
dfs_solution = water_jug_dfs()
print("DFS Solution path:")
if dfs_solution:
    for step in dfs_solution:
        print(step)
else:
    print("No solution found.")

print("-" * 20)

## A* Search Implementation

# Heuristic function: Manhattan distance to the goal
def heuristic(state):
    """
    Estimates the cost from the current state to the goal state.
    Here, it's the minimum difference between the current jug contents and the GOAL.
    """
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    """
    Solves the Water Jug problem using A* Search.
    Returns the optimal path (list of states) to reach the goal, or None.
    Uses f = g + h.
    """
    start = (0, 0)
    # open_list stores (f_score, g_score, path) and is managed as a min-heap
    open_list = []
    # (f_score, g_score, path)
    heapq.heappush(open_list, (heuristic(start), 0, [start]))

    # visited stores the minimum g_score (cost to reach) for each state
    visited = {start: 0}

    while open_list:
        f, g, path = heapq.heappop(open_list)
        state = path[-1]

        # Goal Check
        if state[0] == GOAL or state[1] == GOAL:
            return path

        x, y = state

        # Generate next possible states (possible moves)
        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            # Pour JUG1 to JUG2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour JUG2 to JUG1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if 0 <= nxt[0] <= JUG1 and 0 <= nxt[1] <= JUG2:
                new_g = g + 1  # Cost of the move is 1

                # If a shorter path to nxt is found
                if nxt not in visited or new_g < visited[nxt]:
                    visited[nxt] = new_g
                    new_path = list(path)
                    new_path.append(nxt)
                    new_f = new_g + heuristic(nxt)
                    heapq.heappush(open_list, (new_f, new_g, new_path))

    return None

# Execute A*
a_star_solution = a_star_water_jug()
print("A* Solution path:")
if a_star_solution:
    for step in a_star_solution:
        print(step)
else:
    print("No solution found.")